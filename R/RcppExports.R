# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

condense_count <- function(x, origin, binwidth, z, w) {
    .Call('ggcomp_condense_count', PACKAGE = 'ggcomp', x, origin, binwidth, z, w)
}

condense_sum <- function(x, origin, binwidth, z, w) {
    .Call('ggcomp_condense_sum', PACKAGE = 'ggcomp', x, origin, binwidth, z, w)
}

condense_moments <- function(x, origin, binwidth, z, w, moments) {
    .Call('ggcomp_condense_moments', PACKAGE = 'ggcomp', x, origin, binwidth, z, w, moments)
}

condense_median <- function(x, origin, binwidth, z, w) {
    .Call('ggcomp_condense_median', PACKAGE = 'ggcomp', x, origin, binwidth, z, w)
}

#' Efficient implementation of range.
#'
#' This is an efficient C++ implementation of range for numeric vectors:
#' it avoids S3 dispatch, and computes both min and max in a single pass
#' through the input.
#'
#' @param x a numeric vector, or a \code{\link{ranged}} object
#' @param finite If \code{TRUE} ignores missing values and infinities. Note
#'   that if the vector is empty, or only contains missing values,
#'   \code{frange} will return \code{c(Inf, -Inf)} because those are the
#'   identity values for \code{\link{min}} and \code{\link{max}} respectively.
#' @export
#' @examples
#' x <- runif(1e6)
#' system.time(range(x))
#' system.time(frange(x))
frange <- function(x, finite = TRUE) {
    .Call('ggcomp_frange', PACKAGE = 'ggcomp', x, finite)
}

smooth_linear <- function(x_in, z_in, w_in, x_out, h) {
    .Call('ggcomp_smooth_linear', PACKAGE = 'ggcomp', x_in, z_in, w_in, x_out, h)
}

smooth_robust <- function(x_in, z_in, w_in, x_out, h, iterations = 3L) {
    .Call('ggcomp_smooth_robust', PACKAGE = 'ggcomp', x_in, z_in, w_in, x_out, h, iterations)
}

