# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

condense_count <- function(x, origin, width, pad, right_closed, w) {
    .Call('ggcomp_condense_count', PACKAGE = 'ggcomp', x, origin, width, pad, right_closed, w)
}

condense_sum <- function(x, origin, width, pad, right_closed, z, w) {
    .Call('ggcomp_condense_sum', PACKAGE = 'ggcomp', x, origin, width, pad, right_closed, z, w)
}

condense_moments <- function(x, origin, width, pad, right_closed, z, w, moments) {
    .Call('ggcomp_condense_moments', PACKAGE = 'ggcomp', x, origin, width, pad, right_closed, z, w, moments)
}

condense_median <- function(x, origin, width, pad, right_closed, z, w) {
    .Call('ggcomp_condense_median', PACKAGE = 'ggcomp', x, origin, width, pad, right_closed, z, w)
}

count_lgl <- function(x, w) {
    .Call('ggcomp_count_lgl', PACKAGE = 'ggcomp', x, w)
}

count_factor <- function(x, w) {
    .Call('ggcomp_count_factor', PACKAGE = 'ggcomp', x, w)
}

count_numeric <- function(x, w) {
    .Call('ggcomp_count_numeric', PACKAGE = 'ggcomp', x, w)
}

count_string <- function(x, w) {
    .Call('ggcomp_count_string', PACKAGE = 'ggcomp', x, w)
}

density <- function(x, w, bw, width, from, to, reflect = FALSE) {
    .Call('ggcomp_density', PACKAGE = 'ggcomp', x, w, bw, width, from, to, reflect)
}

frange_ <- function(x, finite = TRUE) {
    .Call('ggcomp_frange_', PACKAGE = 'ggcomp', x, finite)
}

#' Modulus transformation (and its inverse).
#'
#' A generalisation of the box-cox transformation that works for
#' values with both positive and negative values.
#'
#' This is useful for compressing the tails of long-tailed distributions,
#' often encountered with very large datasets.
#'
#' @param x values to transform
#' @param lambda degree of transformation
#' @export
#' @references J. John and N. Draper. "An alternative family of
#'  transformations." Applied Statistics, pages 190-197, 1980.
#'  \url{http://www.jstor.org/stable/2986305}
#' @examples
#' x <- seq(-10, 10, length = 100)
#' plot(x, mt(x, 0), type = "l")
#' plot(x, mt(x, 0.25), type = "l")
#' plot(x, mt(x, 0.5), type = "l")
#' plot(x, mt(x, 1), type = "l")
#' plot(x, mt(x, 2), type = "l")
#' plot(x, mt(x, -1), type = "l")
#' plot(x, mt(x, -2), type = "l")
mt <- function(x, lambda = 0) {
    .Call('ggcomp_mt', PACKAGE = 'ggcomp', x, lambda)
}

#' @export
#' @rdname mt
inv_mt <- function(x, lambda = 0) {
    .Call('ggcomp_inv_mt', PACKAGE = 'ggcomp', x, lambda)
}

resolution_numeric <- function(x, zero = TRUE) {
    .Call('ggcomp_resolution_numeric', PACKAGE = 'ggcomp', x, zero)
}

smooth_linear <- function(x_in, z_in, w_in, x_out, h) {
    .Call('ggcomp_smooth_linear', PACKAGE = 'ggcomp', x_in, z_in, w_in, x_out, h)
}

smooth_robust <- function(x_in, z_in, w_in, x_out, h, iterations = 3L) {
    .Call('ggcomp_smooth_robust', PACKAGE = 'ggcomp', x_in, z_in, w_in, x_out, h, iterations)
}

smooth_mean <- function(x_in, z_in, w_in, x_out, h) {
    .Call('ggcomp_smooth_mean', PACKAGE = 'ggcomp', x_in, z_in, w_in, x_out, h)
}

`as.data.frame!` <- function(x, nrow) {
    invisible(.Call('ggcomp_as_data_frame', PACKAGE = 'ggcomp', x, nrow))
}

weightedQuantile <- function(x, w, probs) {
    .Call('ggcomp_weightedQuantile', PACKAGE = 'ggcomp', x, w, probs)
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call('ggcomp_RcppExport_registerCCallable', PACKAGE = 'ggcomp')
})
